#!/usr/bin/env python3#	mp4_descripter.py#	オリジナル：https://qiita.com/satken2/items/d14b4113fe3fb5f5597b#	↑ここから拾ってきたオリジナルからいくつか書き換えた．##	使用方法(1) コマンドラインからmp4ファイルの構造をリスト#	$ python -m mp4_descripter.py 引数1 [引数2] [引数3]#		1	内容表示したいファイル名#		2	表示したいBOX番号のリスト(カンマとハイフン区切りの整数リスト)#		3	表示長(省略時256byte)##	使用方法(2) importして撮影日情報を抽出#		import mp4_descripter#		mp4taglist = mp4_descripyter.gettag( mp4ファイルパス名, opt )#"""2021/07/17(土)	penrulumを破棄．android pydroidでpip installできないため．	代わりにdatetime.now() - datetime.utcnow() でローカルとutcの時間差を得る．	が# tz deleteed. in android because,pendulum could notinstalled.	2021/07/15(木) タグ抜き出し専用のインターフェイスを新設してモジュール化	こんな感じか：		import mp4_descripter as mp4d		mp4taglist = mp4d.gettag( filename.mp4, opt )			opt = メタデータをutcとして扱う場合は"utc"，それ以外はローカル時刻として扱う			["CTime"] = 撮影開始日時			["MTime"] = 更新日時（保存日時）			["Duration"] = 長さ			["Make"] = 撮影機材メーカー			["Model"] = 機材名	2021/07/13(火) タグから日付を拾う処理をやっと追加開始．	apple quictimeのドキュメントによると，moov BOXあたりに日付や長さについてのメタデータが入っているとのこと．	https://developer.apple.com/library/archive/documentation/QuickTime/QTFF/QTFFChap2/qtff2.html#//apple_ref/doc/uid/TP40000939-CH204-33307	構造体を定義していよいよ目的のタグを抜き出すことにする．	そのため，ダンプ対象データの最小値を16から64にこっそり拡張しておく．	2021/7/13 とりあえずここまでで一段落．	リーフとそうでないBOXのタイトルをいくつか現物合わせで入れ替えた．"""import sysimport binascii# atom名のリスト．ネスト構造を読み進めるため，これ以上にネストすることがない末葉atomと# ネスト可能なatomを識別するためのリスト# サンプルmp4ファイルを読ませて随時追加・訂正しているleaf_list = [	  'cmvd', 'co64', 'ctts'	, 'dcom', "dref"	, 'elst'	, 'fiel', 'free', 'ftyp'	, 'gmhd'	, 'hdlr'	, "ilst"	, "keys"	, 'mdat', 'mdhd', 'mvhd'	, 'rdrf', 'rmcd', 'rmcs', 'rmdr', 'rmqu', 'rmvc'	, 'smhd', 'stco', 'stsc', 'stsd', 'stss', 'stsz', 'stts'	, 'udta', 'uuid'	, 'tkhd'	, 'vmhd'	, 'wfex'	]parent_list = [	  'cmov'	, "dinf"	, 'edts', 'esds'	, 'iods'	, 'junk'	, 'meta', 'mdia', 'minf', 'moov'	, 'pict', 'pnot'	, 'rmda', 'rmra'	, 'skip', 'stbl'	, 'trak'	, 'wide'	]# インタラクティブモードで，leafダンプする際のデフォルト長lengths_limit = 256# ファイルシーク指定定数seek_from = { "top" : 0, "current" : 1, "end" : 2 }""" MP4構造   BOX	これの繰り返し．   	  +0	size=n	(4byte) サイズが 2GB 未満の場合	  +4	type	4byte ascii BOX名称	  +8	payload	データ．3種類の使われ方がある．	  +n-1			最終byte	  -------------	  +n	size=m	次のBOXの先頭		+4	type	...	  +m-1			 最終byte	payload	(1)	子BOXを含む場合		+0	size=l		+4	type		+8	payload...　※さらにネストしていることもある		+l-1 子BOXの最終		+l	次の子BOXまたは親BOX	(2) 子BOXを含まない場合（枝の末端という意味でleafと呼ぶこともあるらしい）		+0	data	boxごとに定義		+8	payload...	(3) BOX長が2GB以上のとき		+0 実際のsize=long	8byte		+8 paynoad typeにより，leafと子BOXのいずれか．		+long - ( 4 + 4 + 8 ) ｐａｙｌｏａｄ最終byte	※子BOXを含むか含まないかはPayload部分にBOX構造があるかどうかをあらかじめ肉眼で確認して，		BOX構造がないならleaf_list．payload部をダンプできる．		あればparent_list．payloadは無いんでダンプ対象外．		登録して識別している．		不明なものはleafとして扱う．""""""	moov 配下に含まれるメタデータBOXの抜粋	apple ドキュメントより引用	moov配下のBOXにメタデータが入ってるらしい．	その中の一つ，mvhdはこんな感じ．ほとんど欲しいモノ全てが揃ったことになる	+00 4	length			00 00 00 6c	+04 4	type "mvhd"		6d 76 68 64:	+08 1	ver.			00	+09 3	flags			00 00 00	+0c 4	creation time	dd 10 06 de (3708815070) これを1904基準との差(-2082844800)	+10 4	moddify time	dd 10 06 de	+14 4	time scale		00 00 27 10:	+18 4	duration		00 00 50 b3	+1c 4	prefered rate	00 01 00 00	+20 2	prefered vol.	01 00	+22 10	reserved	00 00 00 00 00 00:00 00 00 00	+2c 36	matrix		00 01 00 00 00 00 00 00 00 00 00 00:						00 00 00 00 00 01 00 00	00 00 00 00						00 00 00 00:00 00 00 00 40 00 00 00	+50 4	prev. time	00 00 00 00	+54 4	prev. duration	00 00 00 00:	+58 4	poster time	00 00 00 00:	+5c 4	sele. time	00 00 00 00	+60 4	sele. duration	00 00 00 00	+64 4	curr. time	00 00 00 00	+68 4	next track ID	00 00 00 03""""""	Apple文書によると，時刻について	・1904/1/1 00:00:00を0とする秒カウント	・UTCベース	これまでスマホで撮影したファイルをPerlExifToolや，DSCARで改名すると実際の撮影年月日(や，オリジナルのファイルタイムスタンプ)と比べて	日本のUTC+0900分，ずれた時刻で命名されていた．	けれど，よく調べてみたら…	mp4内部のcreation dateもmodification dateもどうやらUTCではなくローカル時刻っぽい．	これをExifToolがUTCだと勘違いしてわざわざローカルに変換してしまうことでズレが発生していたらしい．"""	# mp4 内部で使われている時刻の起源が1904/1/1 0:0:0 UTCのため，	# UNIX系の起源 1970/1/1 0:0:0 UTCとの差を下駄として求めておく．	# さらに，現地時刻 との時差もついでに乗っける．#offset_UNIX_EPOC_SEC = (66 * 365 + 17) * 24 * 3600	# perl exiftoolの表現offset_UNIX_EPOC_SEC = 24107 * 24 * 60 * 60	# 1970/1/1 - 1904/1/1 実日数#日付オプションtz_option = ""#外部へ返すタグ辞書mp4taglist = {}#その初期値mp4taglist_init = {	"Make"	   : "",	"Model"    : "",	"Duration" : 0,	"CTime"    : "",	"MTime"    : ""}class mp4_tag:	"""	引数のファイルに含まれるタグを返す	"""	def __init__(self):		self.duration = 0	#sec		self.ctime = 0		#sec from epoc1970		self.mtime = 0		#sec from epoc1970def mp4_walkthrough( filename, index_list = [ -1 ], atom = "", option = "" ):	"""	コンテナのルートBOXを順に検索する．	args	filename	i	mp4ファイルパス名	index_list	i	0～	ダンプしたいBOX番号のリスト					-1	ダンプしない．実験用，タグ関係で見つけたものがあれば表示					-2	ダンプしない．標準出力に一切出力しない．実用タグ返し用	atom		i	ダンプしたいatom名称．					""	こっちではなくリストを使う	option		i	オプション					"utc"	日付をutcとしてあつかい，ローカル時間に変換した値を返す	"""	import os	import datetime	global tz_option	global mp4taglist	global mp4taglist_init	mp4taglist = mp4taglist_init	file = open( filename,'rb')	if( index_list[0] >= 0 ):		#ツリー無し，番号指定ダンプのみ		out_text = ( "\nINDEX LIST[" + str(sys.argv[2]) + "]" )	#これ不細工なー．	elif( index_list[0] == -1 ):	#ツリーのみ，または個別ダンプのみ		if( atom == "" ):			out_text = ""		else:			out_text = ( "\nATOM[" + atom + "]" )	#ツリー無し．名前指定ダンプのみ．	if( index_list[0] == -2 ):		# 出力はタグリストのみ．表示は一切なし．		pass	else:							# 指定した内容を表示		out_text += "\nNAME[ " + filename + "](" + option + ")"		out_text += "\nDATE[" + str(datetime.datetime.fromtimestamp(os.path.getctime( filename ))) + "]"		out_text += " SIZE[" + str(os.path.getsize( filename )) + "]"		out_text += "\n  #   ADDRESS:  LENGTH:    NEXT:ATOM"		print( out_text )	tz_option = option	#時刻オプション	index = 0	while( index >= 0 ):		index = read_container( file, 0, index, -1, index_list, atom  )	file.close()	if( index_list[0] != -2 ): print( " ..DONE.." )def read_container(file, indent, index, end_offset, index_list, atom ):	"""	再帰呼び出しでネスト構造のBOXペイロードをウォークスルーする	BOXインデックス番号を指定すればそれをダンプする．	args	file			io	ファイルハンドル(オープン済み)	indent			i	呼び出し時点のネストレベル．最初は0から	index			i	呼び出し時点のBOX番号．最初は0から．	end_offset		i	この位置まで検索したら戻る	index_list		i	ダンプしたいBOX番号のリスト						>0		ツリー表示なし．指定番号に一致するBOXをダンプ						== -1, atom=""	ツリー表示のみ．データダンプはなし．						== -1, atom!=""	ツリー表示なし．atomに一致するデータをダンプ						== -2	ツリー表示なし．ダンプや表示は一切なし．タグを返す．	atom			i	番号ではなくatomを探す．ダンプするかしないかは番号リストの値による．	return	index		戻った時点のBOX番号	"""	global limit_length	global tz_option	global mp4taglist	"""	現在のポインタを基準して，コンテナサイズやらタイプやらを順に拾っていく	現コンテナ長が0ならおしまい．	"""	# file current pointer. start of container	fcp = file.tell()	# length of container	data_size32 = file.read( 4 )	size = int.from_bytes( data_size32, byteorder='big' )	# when container size exceeds 2147483647	if( size == 0 ): # end of file		return -1	else:		# type of container		data_type = file.read( 4 )		type = data_type.decode( "utf-8" )		is_leaf = ( type in leaf_list )		if( size != 1 ):	# normal box			# pointer of next container			end = fcp + size			data_size64 = 0		else:				# large box			data_size64 = file.read( 8 ) # long byte			size = int.from_bytes( data_size64, byteorder='big' )			# pointer of next container			end = fcp + size	# ここまでで主要変数の中身はこんな感じ：．	# file.tell() := start of payload or child box.	# size := length of the box	# end  := start point of next box	if( is_leaf == 0 ):	# ネストしてそう		is_parent = type in parent_list		# ↓にひっかかるのはエラーみたいなもんだから表示を許す		if( is_parent == 0 ): print( "UNKNOWN ATOM FOUND:", type, "is parent ?=", is_parent )	# make index string	out_text = "{:3d} {:08x}:{:08x}:{:08x}:".format( index, fcp, size, end )	#ファイル先頭からBOX番号	out_text += ( "| " * indent	) if( index_list[0] < 0 ) else ""				#ネストレベル分字下げ	out_text += "{:s}".format( type )	out_text += " is container" if( not is_leaf ) else ""	out_text += " is large" if( data_size64 ) else ""	"""		条件					ツリー表示	atom表示	そのほか		list == -1 & atom == ""	o			x			x		list == -1 & atom != ""	x			atom		(tag)		list >= 0				x			list		(tag)		list == -2				x			x			tagを返す	"""	if( ( index_list[0] == -1 ) and ( atom == "" ) )			\	or( ( index_list[0] == -1 ) and ( atom == type ) )			\	or( ( index_list[0] >=	0 ) and ( index in index_list ) )	: print( out_text )	if is_leaf:		"""		ペイロードを読むか飛ばすか：		・タグが含まれているBOXはちゃんと読む．		・ダンプ指定のBOXならちゃんとよむ．		それ以外は読み飛ばす		"""		# 内容を読み取る必要のあるatomを見つけた		if( index in index_list ) or ( type == atom ):			# todo index == -2の時は切り捨て条件を外した方がいいかも．（それともatom名で必要な長さがわかる？）			# 巨大なブロックは指定長を上限に出力を端折る			if( size > lengths_limit ):				size_truncated = lengths_limit			else:				size_truncated = size			# ダンプすることを想定して，atom先頭から読み直す			file.seek( fcp, 0 )			data = file.read( size_truncated )			# ダンプ			if( ( index_list[0] >=	0 ) and (	"" == atom ) )	\			or( ( index_list[0] == -1 ) and ( type == atom ) ):				dump_bytesarray( data )				if( size_truncated != size ):					out_text = "\t ...length truncated..."					print( out_text )			## タグの抜き出し			if( type == "mvhd" ):				"""				時間とか長さとか				mp4の時刻期限から経過秒と数え方は同じだけど，紀元が1904/1/1，一方UNIX系1970/1/1．				とズレがある．それと，mp4内はUTCなんでローカル時間に換算が必要．				"""				import struct				import time				#import pendulum	android Pydroidで使えない．				from datetime import datetime				global mp4_datetime				ts_utc_qt_ctime, ts_utc_qt_mtime, scale_in_sec, msec_duration = struct.unpack( ">IIII",  data[12:12 + 16] )				ts_utc_ctime = ts_utc_qt_ctime - offset_UNIX_EPOC_SEC				ts_utc_mtime = ts_utc_qt_mtime - offset_UNIX_EPOC_SEC				# ts_utc_* は本当はほとんどの場合はutcではなくてローカル時間が入ってるそうだ．				# なんで，オプション "utc"を付けた場合にだけローカルタイムゾーンとの時差を加える．				if( tz_option == "utc" ):					# pendulumはandroidでは使えない．					#tz = pendulum.now().strftime( "%z" )					#ts_tz = ( int( tz[0:3] ) * 60 + int( tz[3:] ) ) * 60					#代わりにおおざっぱにUTCとローカルの時差をunix時間で求める					ts_tz = int( ( datetime.now() - datetime.utcnow() ).seconds )				else:					ts_tz = 0				#endif: #目印．pythonが気に入らないのは仮にコメントアウトするのにインデントも動かす必要があること．				ts_ntv_ctime = ts_utc_ctime + ts_tz				ts_ntv_mtime = ts_utc_mtime + ts_tz				mp4taglist["Duration"] = ( msec_duration / scale_in_sec ) if( scale_in_sec != 0 ) else 0				mp4taglist["CTime"] = datetime.fromtimestamp( ts_ntv_ctime - mp4taglist["Duration"] ).strftime( "%Y/%m/%d %H:%M:%S" )				mp4taglist["MTime"] = datetime.fromtimestamp( ts_ntv_mtime ).strftime( "%Y/%m/%d %H:%M:%S" )				if( index_list[0] != -2 ):					print( "\t--- DATE TIME, LENGTH --- (DIFF LOCAL AND MP4 DATE=[", ts_tz, "SEC])" )					print( "\tSCALE IN SEC[", scale_in_sec,  "]  TIME DURATION[", mp4taglist["Duration"], "SEC]" )					print( "\tVALUE HEX\t\t\tEPOC1904\tEPOC1970\tDATE-TIME\t\t\tIN LOCAL" )					print( "\tCTIME " + str(hex(ts_utc_qt_ctime)) + "\t" + str( ts_utc_qt_ctime ) + "\t" + str( ts_utc_ctime ) + "\t" + str( datetime.fromtimestamp( ts_utc_ctime ) ) + "\t" + str( datetime.fromtimestamp( ts_ntv_ctime ) ) )					print( "\tMTIME " + str(hex(ts_utc_qt_mtime)) + "\t" + str( ts_utc_qt_mtime ) + "\t" + str( ts_utc_mtime ) + "\t" + str( datetime.fromtimestamp( ts_utc_mtime ) ) + "\t" + str( datetime.fromtimestamp( ts_ntv_mtime ) ) )		file.seek( end, 0 )	#読んだどうかは無関係に次の先頭まで進める		return index + 1	else:	### コンテナ．ネストした中身を読み進む		if( index_list[0] != -2 ):			if( index in index_list ) or ( type == atom ):				print( "\t..NO DATA.." )		index += 1		while True:			# digging more			index = read_container( file, indent + 1, index, end, index_list, atom )			if file.tell() >= end: break		return indexdef dump_bytesarray( data ):	"""	HEXダンプ	args	in	data	出力バイト配列	この関数は特定のBOXをダンプしたいときにだけ呼び出される．	※標準出力が不要なときは呼び出ししないこと．	"""	strarray = str(binascii.hexlify(data))[2:-1]	#最長何文字変換できるのかなこれ．	#長さ	左端のアドレス桁数を求める	ldigits = len( hex( len(data) - 1 )[2:] )	#厳密にいうと長さが1以上ある必要が	# header of hex dump ※毎回組み立てる必要あるか？	dumpstr = "  " + ( " " * ldigits )	dumpchar = ""	for i in range(16):		hexstr = "%x" % i		dumpstr += "+" + hexstr + ( ":" if( i == 7 ) else " " )		dumpchar += hexstr	print( dumpstr + ":" + dumpchar )	#dump data	dumpstr = " %0*x:" %( ldigits, 0 )	dumpchar = ""	for i in range(int(len(strarray) / 2)):		temp = strarray[i*2:i*2+2]		#if( i > 0 ):		if i % 16 == 0:		# 行単位に出力			if( i != 0 ): print(dumpstr + " :" + dumpchar )			dumpstr = " %0*x:" %( ldigits, i )			dumpchar = ""		elif i % 8 == 0:			dumpstr += ":"		else:			dumpstr += " "		dumpstr += temp		tempval = binascii.unhexlify(temp)		tempchar = "." if( tempval < b" " or tempval > b"~" ) else str( tempval )[2:3]		dumpchar += tempchar	# 未出力ののがあれば桁合わせをして出力	print( dumpstr + " " * ( 48 + ldigits + 2 - len(dumpstr) ) + ":" + dumpchar  )def parse_IntList( s, atom_return ):	"""	単一の文字列から，整数のリストを返す．	args		s	i	整数値と区切り文字，連続記号が混ざった単一の文字列					※昇順でないとちゃんと範囲補完できない．					※区切り文字は","または"."．					※数値化できない値は破棄．					※重複値の掃除はしない．				または，単一のatom名．4文字．この場合は番号リストは [-1]を返す．	return		分割，補完した整数のリスト	ざっくりした定義．以下の組み合わせ．文法エラーはおおらかに無視する．	整数	([0-9]+)	区切り	(,)	連続	(-)	atom名	xxxx	必ず4文字で記号を含まない(細かいことは検査していない)	特別な数値	"-1"	リストを省略した(=指定しなかった)ことを意味する．	"""	import re	atom_return[0] = ""	# 最初に区切り文字で分割する．(コマンドラインだと改行はないと思うけど念のため)	if ( len( s ) == 4 				) and( not re.search( r"[-.,\n\t]+", s )	):	#長さが4文字で,区切りや負号がなければatomとみなす		l_3rd = [ -1 ]			# リストは空に		atom_return[0] = s		# atomを返す	else:		l_3rd = []		atom_return[0] = ""		l_1st = re.split( r"[ ,\n\t]+", s )		for e in l_1st:			if( "-" in e ):		#連続値．間を補完してリストへ．				if( e == "-1" ):	#全リスト出力フラグを見つけたらそこでおしまい					l_3rd = [ -1 ]					break				else:					l_2nd = e.split( "-" )					try:						i_from = int( l_2nd[0] )						i_to   = int( l_2nd[1] ) + 1	#終了値を含めるため1加算					except:						pass	# 黙って破棄					else:						for i in range( i_from, i_to ):							l_3rd.append( i )			else:				# 単独値．そのままリストへ．				try:					i_from = int( e )				except:					pass		# 黙って破棄				else:					l_3rd.append( i_from )		if( len(l_3rd) < 1 ):			l_3rd = [ -1 ]	print( "indexlist[", l_3rd, "]  atom[", atom_return[0], "]" )	return l_3rddef gettag( filename, opt ):	"""	実用関数モード．	返せるタグのリストを返す．標準出力へは何もださない．	args		filename	i	mp4ファイルパス名		opt			i	オプション．						"utc"	メタタグをutcとして扱い，ローカル時間に換算した値を返す	return		class mp4_tagのインスタンス	スコープはどういう扱いになるのか知らない．	"""	import os	global mp4taglist	#ちょっと志を低くして辞書テーブル渡しに退化	try:		if( not os.path.isfile( filename ) ):			raise "file not ready to open"	except:		pass	else:		try:			# 返せるタグがあるatomを名指しで呼ぶ．他にあれば追加する．			mp4_walkthrough( filename, [ -2 ], atom = "mvhd", option = opt )		except:			pass	return mp4taglistdef	main():	"""	インタラクティブモード．	引数なし：説明表示して終了	引数1個：mp4ファイル名．構造リストに番号#を付加して表示する	引数2個：ダンプしたいatomの出現順の番号リスト，または1個のatom名	引数3個：ダンプ最長文字数(最少=16,省略=256)	"""	import os	global lengths_limit	atom = ""	haveerror = ""	# 表示するatom番号リスト	index_list = [ -1 ]	# 表示するatom名 オプション	atom_return = [ "" ]	# 関数から値を戻すためにリストにする	# 表示するファイル名	filename = ""	try:		filename = sys.argv[1]	except Exception:		haveerror = "need file name"		pass	if( not os.path.isfile( filename ) ):		haveerror = "file open error:" + filename	else:		# ダンプしたいBOX番号のリスト，またはatom名．単一トークンに収まる範囲で指定する．		# オプション無し，または-1ならダンプしない．ファイル全体の構造表示をする		try:			index_list = parse_IntList( sys.argv[2], atom_return )			atom = atom_return[0]		except Exception:			index_list[0] = -1			pass		# ダンプする場合，長すぎる場合の打ち切り長		# オプション無しなら 256byteを上限にする．短い方は1行ピッタリ16byteでもいいんだけど，		# タグをのぞき見したい理由もあって64byteにしておく．		try:			lengths_limit = int(sys.argv[3])			lengths_limit = lengths_limit if( lengths_limit > 64 ) else 64		except Exception:			lengths_limit = 256			pass	if( haveerror != "" ):		print( "Error: " + haveerror )		print( "usage: mp4_descripter.py filepath [index] [length]",			"\n\t filepath: mp4 [path]filename.",			"\n\t index   : dump box(es) where index# found.",			"\n\t\tex) 1 .....One only."			"\n\t\t    1,3 ...One and Three."			"\n\t\t    1-10 ..One upto Ten."			"\n\t\t    mvhd ..One atom name."			"\n\t\t    -1 or nothing assum no dump, list only.",			"\n\t length  : limit of dump length.",			"\n\t\t 256 bytes as default." )		sys.exit(0)	opt = ""	# 面倒だからインタラクティブモードでは放置	mp4_walkthrough( filename, index_list, atom, option = opt )if __name__ == '__main__':	main()